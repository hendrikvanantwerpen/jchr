
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 *     __   __)  __     __)     _                                                    *
 *    (, ) /    (, /   /    ___/__)                                                  *
 *      /(        /   /    (, /    _     _ _   _ __                                  *
 *   ) /  \_  o  /   /    o  /   _(/_(_(_(/___(/_/ (_                                *
 *  (_/     JJJJ(___(_J     (_____CCCCCCCCHHHHHHHHH     HHHHHHHHHRRRRRRRRRRRRRRRRR   *
 *         J:::::::::J   CCC::::::::::::CH:::::::H     H:::::::HR::::::::::::::::R   *
 *         J:::::::::J CC:::::::::::::::CH:::::::H     H:::::::HR::::::RRRRRR:::::R  *
 *         JJ:::::::JJC:::::CCCCCCCC::::CHH::::::H     H::::::HHRR:::::R     R:::::R *
 *           J:::::J C:::::C       CCCCCC  H:::::H     H:::::H    R::::R     R:::::R *
 *           J:::::JC:::::C                H:::::H     H:::::H    R::::R     R:::::R *
 *           J:::::JC:::::C                H::::::HHHHH::::::H    R::::RRRRRR:::::R  *
 *           J:::::jC:::::C                H:::::::::::::::::H    R:::::::::::::RR   *
             J:::::JC:::::C                H:::::::::::::::::H    R::::RRRRRR:::::R  *
 JJJJJJJ     J:::::JC:::::C                H::::::HHHHH::::::H    R::::R     R:::::R *
 J:::::J     J:::::JC:::::C                H:::::H     H:::::H    R::::R     R:::::R *
 J::::::J   J::::::J C:::::C       CCCCCC  H:::::H     H:::::H    R::::R     R:::::R *
 J:::::::JJJ:::::::J  C:::::CCCCCCCC::::CHH::::::H     H::::::HHRR:::::R     R:::::R *
  JJ:::::::::::::JJ    CC:::::::::::::::CH:::::::H     H:::::::HR::::::R     R:::::R *
    JJ:::::::::JJ        CCC::::::::::::CH:::::::H     H:::::::HR::::::R     R:::::R *
 *    JJJJJJJJJ             CCCCCCCCCCCCCHHHHHHHHH     HHHHHHHHHRRRRRRRR     RRRRRRR *
 *                                                                                   *
 * This file was generated by the K.U.Leuven JCHR System                             *
 * (available at http://www.cs.kuleuven.be/~petervw/JCHR/).                          *
 *                                                                                   *
 * Do not edit: edit the jchr-source file instead.                                   *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

package jchr.example.gcd;
import be.kuleuven.jchr.runtime.list.ConstraintLinkedList;
import be.kuleuven.jchr.runtime.list.HashMapConstraintLinkedList;
import be.kuleuven.jchr.runtime.Handler;
import be.kuleuven.jchr.runtime.Constraint;

import be.kuleuven.jchr.annotations.JCHR_Constraints;
import be.kuleuven.jchr.annotations.JCHR_Constraint;
import be.kuleuven.jchr.annotations.JCHR_Tells;

import be.kuleuven.jchr.util.Cloneable;
import be.kuleuven.jchr.util.iterator.*;
import be.kuleuven.jchr.util.AbstractUnmodifiableCollection;

import java.util.HashMap;
import java.util.Collection;
import java.util.Iterator;


/**
 * @author Peter Van Weert
 */
@JCHR_Constraints({
	@JCHR_Constraint(
		identifier = "gcd",
		arity = 1
			)
})
public class GcdHandler extends Handler {

public GcdHandler() {
}

/*
 * SOLVERS
 **************/ 

/*
 * TELL METHODS
 **************/
	@JCHR_Tells("gcd")
	public final void tellGcd(
		long $X0 
	) {
		new GcdConstraint(
		$X0
	,
			this
		).activate();
	}

/*
 * CONSTRAINTSTORE
 *********************/
	/*
	 * INDICES VOOR GCD-CONSTRAINT
	 ******************************************/
	private final 	ConstraintLinkedList<GcdConstraint>
 	gcdConstraintList
 = new 	ConstraintLinkedList<GcdConstraint>
();

	/**
	 * Adds the given constraint-object <code>constraint</code> to the
     * constraint store. 
	 *
	 * @param constraint
	 * 	The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the
	 *	store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeGcd(
		GcdConstraint constraint
	) {
						gcdConstraintList
.addFirst(constraint);
	}
	
	/*
	 * LOOKUP-METHODS VOOR GCD-CONSTRAINT
	 *******************************************/
			/**
			 * Returns an iterator over all <code>GcdConstraint</code>s currently
			 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
			 * Besides that, we offer very few guarantees about the behavior of these iterators:
			 * <ul>
			 *  <li>
			 *      There are no guarantees concerning the order in which the constraints 
			 *      are returned.
			 *  </li>
			 *  <li>
			 *      The iterators <em>might</em> fail if the constraint store is structurally modified
			 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
			 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
			 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
			 *      non-deterministic behavior at an undetermined time in the future.
			 *      <br/>
			 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
			 *      even for single-threaded applications (this constraint is inherited from the 
			 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
			 *      and should only be used to detect bugs. 
			 *      <br/>
			 *      Important is that, while <code>Iterator</code>s returned by collections of the 
			 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
			 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
			 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
			 *      and fail cleanly when this is not possible (or possibly to expensive). So,
			 *      in general you can get away with many updates on the constraint store during
			 *      iterations (there is no way of telling which will fail though...)
			 *  </li>
			 *  <li>
			 *      As a general note: structural changes between calls of hasNext() and next()
			 *      are a bad idea: this easily leads to <code>ConcurrentModificationException</code>s.
			 *  </li>
			 *  <li>
			 *      The failure of the <code>Iterator</code> might only occur some time after
			 *      the structural modification was done: this is again because many parts
			 *      of the constraint store are iterable in the presence of modification.
			 *  </li>
			 *  <li>
			 *      When a constraint is added to the constraint store after the creation of the
			 *      iterator it is possible it appears somewhere later in the iteration, but
			 *      it is equally possible it does not.
			 *  </li>
			 *  <li>
			 *      Removal of constraints on the other hand does mean the iterator will never return
			 *      this constraint.
			 *      Note that it still remains possible that the iterator fails somewhere after
			 *      (and because of) this removal.
			 *  </li>
			 * </ul>
			 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
			 * in the presence of constraint store updates, whilst others do not. Some might return
			 * constraints in order of their creation (and only iterate over constraints that existed
			 * at the time of their creation), others do not. In fact: it is perfectly possible that 
			 * their behavior changes between two compilations (certainly when moving to a new version
			 * of the compiler). This is the price (and at the same time the bless) of declarative 
			 * programming: it is the compiler that chooses the data structures that seem optimal 
			 * to him at the time!
			 *
			 * @return An iterator over all <code>GcdConstraint</code>s currently
			 * 	in the constraint store.
			 */
			public Iterator<GcdConstraint> lookupGcd() {
					return 	gcdConstraintList
.iterator();
			}
			
			/**
			 * Returns (an unmodifiable view of) the current collection of 
			 * <code>GcdConstraint</code>s currently in the constraint store. 
			 * Iterators over this collection are the equivalents of those
			 * created by the <code>lookupGcd</code>-method.
			 * We refer to this method for more information on their behavior.
			 * This collection is backed by the constraint store: updates 
			 * to the store will be reflected in the collection.
			 *
			 * @return (An unmodifiable view of) the current collection of 
			 * 	<code>GcdConstraint</code>s currently 
			 *	in the constraint store. 
			 *
			 * @see #lookupGcd
			 */
			public Collection<GcdConstraint> getGcdConstraints() {
	// This implementation is still very inefficient: 
	// don't over-use this feature yet!
	return new AbstractUnmodifiableCollection<GcdConstraint>() {
        @Override
        public int size() {
            return IteratorUtilities.size(iterator());
        }

        @Override
        public Iterator<GcdConstraint> iterator() {
            return 					lookupGcd()
;
        }
	};
			}
		
			
		
		


	/**
	 * {@inheritDoc}
	 *
	 * @see #lookupGcd()
	 */
	@Override
	@SuppressWarnings("unchecked")
	public Iterator<Constraint> lookup() {
		return new ChainingIterator<Constraint>(
				lookupGcd()
		);
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see #lookupGcd()
	 */
	@Override
	@SuppressWarnings("unchecked")
	public Iterator<Constraint> iterator() {
		return new ChainingIterator<Constraint>(
				lookupGcd()
		);
	}

    
    // This implementation is still very inefficient: 
	// don't over-use this feature yet!
	@Override
	public int size() {
        return IteratorUtilities.size(iterator());
    }
    
    @Override
    public boolean isEmpty() {
		return !iterator().hasNext();
    }
}

